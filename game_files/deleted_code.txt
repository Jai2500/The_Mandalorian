SCREEN.PY


_kbhit = KBHit()

TERM_SCREEN = Screen()
screen_dim = TERM_SCREEN.get_dim()

TEST_GAMERULE = Gamerule(0.3)
TEST_SHAPE = np.array([[' ', 'o', ' '],
                       ['/', '|', ' '],
                       ['|', '|', ' ']])

TEST_SHAPE_2 = np.array([[' ', '*', ' '],
                         ['/', 'o', '\\'],
                         ['|', '|', '|']])

test_obj_shape = np.array([['-', ' ', ' ', ' ', ' ', ' '],
                           [' ', '-', ' ', ' ', ' ', ' '],
                           [' ', ' ', '-', ' ', ' ', ' '],
                           [' ', ' ', ' ', '-', ' ', ' '],
                           [' ', ' ', ' ', ' ', '-', ' '],
                           [' ', ' ', ' ', ' ', ' ', '-']
                          ])


# def generate_coins(obj_number):
#     size = np.random.randint(2, 5, 2)
#     coin_list = []
#     for i in range(size[0]):
#         for j in range(size[1]):
#             coin_list.append(Coin([4 + i, 5 + j], obj_number + i * j + j))
#     print(size)

# # Check for printing and how it is done?

# GROUND_SHAPE = np.array([['-' for i in range(screen_dim[1])]
#                         for j in range(int(screen_dim[0] * 0.1))],
#                         dtype='<U100')

# ROOF_SHAPE = np.array([['-' for i in range(screen_dim[1])]],
#                       dtype='<U100').reshape(1, screen_dim[1])


# GROUND_OBJ = Pawn(GROUND_SHAPE, [screen_dim[0] - int(screen_dim[0] * 0.1), 0],
#                   1, 0)

# generate_coins(30)

# ROOF_OBJ = Pawn(GROUND_SHAPE, [1, 0], 10, 0,)

# test_obj = Pawn(test_obj_shape, [13, 14], 2)
# test_magnet = Magnet([14, 30], 8, force_const=4)
# test_magnet_2 = Magnet([20, 80], 15, force_const=1.3)
# TEST_PAWN = Actor(TEST_SHAPE, [4, 4], 4,  1, pawn_type=1)
# TEST_PAWN_2 = Character(TEST_SHAPE_2, [6, 12], 5, 1, pawn_type=1, lives=1)
# test_firebeam = Firebeam([13, 94], 3)
# # test_firebeam.velocity[1] = - 4 
# test_bullet = Bullet([4, 10], 6, 0.0, 0)
# BOSS = Boss_Enemy([10, 10], 19, 20)
# print(BOSS.sprite, BOSS.sprite.shape)
# # test_magnet.velocity[1] = 0.8
# PAWN_LIST = deque([ROOF_OBJ, GROUND_OBJ, test_obj, test_firebeam, TEST_PAWN_2])

# # for i in range(5):
# #     a = Coin([i + 20, 7], i + 10)
# #     PAWN_LIST = PAWN_LIST[:1+i] + [a] + PAWN_LIST[1 + i:]  

# # PAWN_ARRAY = np.array(PAWN_LIST)
# MAGNET_LIST = [3]
# PAWN_DICT = {}
# # print(test_firebeam.type, test_firebeam.size)
# # time.sleep(5)
# _ = TERM_SCREEN.add_pawn(PAWN_LIST)
# print('\x1B[?25l')
# # PAWN_ARRAY[PAWN_DICT[5]].activate_shield()
# # print(PAWN_ARRAY[PAWN_DICT[5]].shield_active, PAWN_ARRAY[PAWN_DICT[5]].sprite)
# while True:
#     # print(PAWN_DICT)
#     time.sleep(0.033)
#     now = datetime.now()
#     TERM_SCREEN.reset_screen()
#     if _kbhit.kbhit():
#         inp = _kbhit.getch().lower()
#         if inp == 'w':
#             PAWN_LIST[PAWN_DICT[5]].velocity[0] -= 2
#         elif inp == 'a':
#             PAWN_LIST[PAWN_DICT[5]].velocity[1] -= 3
#         elif inp == 'd':
#             PAWN_LIST[PAWN_DICT[5]].velocity[1] += 3
#         elif inp == 'e':
#             PAWN_LIST.append(Bullet([PAWN_LIST[PAWN_DICT[5]].position[0], PAWN_LIST[PAWN_DICT[5]].position[1] + 4] , 23, 0))
#             # print(inp)
#             # print(PAWN_ARRAY[PAWN_DICT[5]].shield_active)



#     if PAWN_LIST[PAWN_DICT[5]].shield_active is True:
#         if (now - PAWN_LIST[PAWN_DICT[5]].timestamp).seconds >= 10:
#             PAWN_LIST[PAWN_DICT[5]].deactivate_shield()
#     # for i in MAGNET_LIST:
#         # print(i)
#         # print(PAWN_LIST[8])
#     # if PAWN_LIST[PAWN_DICT[5]].shield_active is False:
#     #     PAWN_LIST[PAWN_DICT[5]] = PAWN_LIST[PAWN_DICT[8]].on_trigger(PAWN_LIST[PAWN_DICT[5]])
#         # PAWN_LIST[PAWN_DICT[5]] = PAWN_LIST[PAWN_DICT[15]].on_trigger(PAWN_LIST[PAWN_DICT[5]])
#         # print(PAWN_LIST[4])
#     for i in range(len(PAWN_LIST)):
#         PAWN_LIST[i] = TEST_GAMERULE.simulate_physics(PAWN_LIST[i])
#     to_delete = TERM_SCREEN.add_pawn(PAWN_LIST)
#     for i in to_delete:
#         del PAWN_LIST[i]
#     # PAWN_LIST = np.delete(PAWN_LIST, to_delete)
#     # print(TERM_SCREEN.game_score)
#     TERM_SCREEN.draw()

# The position and the velocity keeps on increasing despite the ground
# How will this work?
# A fore and back cycle that first prints the fore and then the back ?
# Make a dictionary that refers object number to the object

# Make a dictionary of the magnets present on the screen and check for that with the isin command before deleting so that I can again go back to doing everything
# Update the object dictionary through an update dictionary option
# Create a shield cycle that checks if the shield is active or can be active 